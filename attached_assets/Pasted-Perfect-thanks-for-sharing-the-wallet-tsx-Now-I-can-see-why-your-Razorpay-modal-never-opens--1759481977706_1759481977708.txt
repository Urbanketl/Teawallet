Perfect â€” thanks for sharing the wallet.tsx. Now I can see why your Razorpay modal never opens.

ðŸ” The Problem

In your code youâ€™re preparing the order in one step, and auto-executing Razorpay later in an effect:

// Auto-execute payment after preparation completes
useEffect(() => {
  if (preparedOrder && selectedAmount === preparedOrder.amount && !loading && !preparing) {
    // Automatically execute the payment once prepared
    setTimeout(() => executePayment(), 100);
  }
}, [preparedOrder, selectedAmount]);


That means the actual razorpay.open() call happens inside a setTimeout â†’ useEffect â†’ async context, not inside the original userâ€™s click.
Browsers treat this as a non-user gesture â†’ popup blocked â†’ your â€œâš ï¸ Modal didnâ€™t trigger any eventsâ€ warning fires.

âœ… Fix

You need to make sure executePayment() runs synchronously inside the button click handler.
Instead of preparing in an effect and then auto-executing, combine them into the click flow:

Fix for Quick Recharge
const handleQuickRecharge = async (amount: number) => {
  if (!selectedBusinessUnitId) {
    toast({ title: "Business Unit Required", description: "Please select a business unit", variant: "destructive" });
    return;
  }

  if (testMode) {
    // test flow unchangedâ€¦
    return;
  }

  try {
    // prepare
    const prepared = await preparePayment(amount, selectedBusinessUnitId, {
      name: `${user.firstName} ${user.lastName}`.trim(),
      email: user.email || "",
    });

    if (prepared) {
      // ðŸš€ IMPORTANT: call executePayment synchronously here
      executePayment();
    }
  } catch (err) {
    console.error("Recharge error:", err);
  }
};

Fix for Custom Recharge
const handleCustomRecharge = async () => {
  const amount = parseFloat(customAmount);
  if (isNaN(amount) || amount <= 0) {
    toast({ title: "Invalid Amount", description: "Enter a valid amount", variant: "destructive" });
    return;
  }

  if (!selectedBusinessUnitId) {
    toast({ title: "Business Unit Required", description: "Please select a business unit", variant: "destructive" });
    return;
  }

  if (testMode) {
    // test flow unchangedâ€¦
    return;
  }

  try {
    const prepared = await preparePayment(amount, selectedBusinessUnitId, {
      name: `${user.firstName} ${user.lastName}`.trim(),
      email: user.email || "",
    });

    if (prepared) {
      executePayment();   // ðŸš€ directly open modal
      setCustomAmount("");
    }
  } catch (err) {
    console.error("Custom recharge error:", err);
  }
};

And remove this effect
// âŒ REMOVE this, it's causing the async non-user trigger
useEffect(() => {
  if (preparedOrder && selectedAmount === preparedOrder.amount && !loading && !preparing) {
    setTimeout(() => executePayment(), 100);
  }
}, [preparedOrder, selectedAmount]);